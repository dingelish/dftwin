<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<b>DEBUGGER_SHELL</b>::<a class="el" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html">ICUSTOM_INSTRUMENTOR</a></div>
<h1>DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR Class Reference<br>
<small>
[<a class="el" href="group__DEBUGGER__SHELL.html">DEBUGGER_SHELL</a>]</small>
</h1><!-- doxytag: class="DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR" --><code>#include &lt;debugger-shell.H&gt;</code>
<p>
<a href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html#6523f883bd29a2fb6653d6635e6fd41f">InsertBreakpointBefore</a> (INS ins, BBL bbl, <a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a> order, const std::string &amp;message)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html#99f86e7f6bca2db714472030886baaaa">InsertBreakpointAfter</a> (INS ins, BBL bbl, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> ipoint, <a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a> order, const std::string &amp;message)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html#e671031445d1421e32201e42675fa3ca">~ICUSTOM_INSTRUMENTOR</a> ()=0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Some tools may need to define their own analysis routine that stops at a debugger breakpoint. Such tools can define their own class, which derives from <a class="el" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html">ICUSTOM_INSTRUMENTOR</a>. Pass a pointer to that object to <a class="el" href="structDEBUGGER__SHELL_1_1STARTUP__ARGUMENTS.html#51ccc8add8f440c71cc682d101767bbd">STARTUP_ARGUMENTS::_customInstrumentor</a>.<p>
Most tools do not need to override the default instrumentation, so most tools need not use this interface. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e671031445d1421e32201e42675fa3ca"></a><!-- doxytag: member="DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR::~ICUSTOM_INSTRUMENTOR" ref="e671031445d1421e32201e42675fa3ca" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR::~ICUSTOM_INSTRUMENTOR           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys the custom instrumentor object. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6523f883bd29a2fb6653d6635e6fd41f"></a><!-- doxytag: member="DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR::InsertBreakpointBefore" ref="6523f883bd29a2fb6653d6635e6fd41f" args="(INS ins, BBL bbl, CALL_ORDER order, const std::string &amp;message)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual VOID DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR::InsertBreakpointBefore           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BBL&nbsp;</td>
          <td class="paramname"> <em>bbl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The debugger shell calls this method to insert a "then" instrumentation call to an analysis routine that stops at a debugger breakpoint _before_ an instruction. The default instrumentation looks like this. Tools that implement this method should insert similar instrumentation:<p>
<div class="fragment"><pre class="fragment">  VOID <a class="code" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html#6523f883bd29a2fb6653d6635e6fd41f">InsertBreakpointBefore</a>(INST ins, BBL bbl, <a class="code" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a> order, <span class="keyword">const</span> std::string &amp;message)
  {
      <a class="code" href="group__INS__INST__API.html#g952b2b061d3fa8f1cc4d5d59fef53a69">INS_InsertThenCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR)TriggerBreakpointBefore,
          <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>, order,
          <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dadb6e5681193cc8435b9e57d13acf5d4">IARG_THREAD_ID</a>,
          <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dbd19b79248899659441e56e4738d5bfd">IARG_UINT32</a>, static_cast&lt;UINT32&gt;(RegSkipOne),
          <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d7a11763427dff3afb81caab97b02881b">IARG_PTR</a>, message.c_str(),
          IARG_END);
  }

  VOID TriggerBreakpointBefore(<a class="code" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, <a class="code" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, UINT32 regSkipOne, <span class="keyword">const</span> <span class="keywordtype">char</span> *message)
  {
      ADDRINT skipPc = <a class="code" href="group__CONTEXT__API.html#gc1358a6179f0a63300fdf34ecf8b741d">PIN_GetContextReg</a>(ctxt, static_cast&lt;REG&gt;(regSkipOne));
      ADDRINT pc = <a class="code" href="group__CONTEXT__API.html#gc1358a6179f0a63300fdf34ecf8b741d">PIN_GetContextReg</a>(ctxt, REG_INST_PTR);
      <span class="keywordflow">if</span> (skipPc == pc)
          <span class="keywordflow">return</span>

      <a class="code" href="group__CONTEXT__API.html#g2369ec2d95122f62cb3673a5a3507023">PIN_SetContextReg</a>(ctxt, static_cast&lt;REG&gt;(regSkipOne), pc);
      <a class="code" href="group__APPDEBUG__API.html#gd46f50d48ebcf2414e766c2978111c4b">PIN_ApplicationBreakpoint</a>(ctxt, tid, FALSE, message);
  }
</pre></div><p>
See the method <a class="el" href="classDEBUGGER__SHELL_1_1ISHELL.html#ce2e35422f0c94d70a4eca294c63454e">ISHELL::GetSkipOneRegister()</a> for the register number to use for <em>RegSkipOne</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>Insert the instrumentation before this instruction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bbl</em>&nbsp;</td><td>The basic block containing <em>ins</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>order</em>&nbsp;</td><td>The instrumentation call order to use for the instrumentation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>String telling why the breakpoint is triggered. The string is allocated in permanent storage, so the client can pass it directly to an analysis routine. If the debugger shell removes instrumentation, it will also deallocate this string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="99f86e7f6bca2db714472030886baaaa"></a><!-- doxytag: member="DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR::InsertBreakpointAfter" ref="99f86e7f6bca2db714472030886baaaa" args="(INS ins, BBL bbl, IPOINT ipoint, CALL_ORDER order, const std::string &amp;message)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual VOID DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR::InsertBreakpointAfter           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BBL&nbsp;</td>
          <td class="paramname"> <em>bbl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>ipoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The debugger shell calls this method to insert a "then" instrumentation call to an analysis routine that stops at a debugger breakpoint _after_ an instruction. The default instrumentation looks like this. Tools that implement this method should insert similar instrumentation:<p>
<div class="fragment"><pre class="fragment">  VOID <a class="code" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html#99f86e7f6bca2db714472030886baaaa">InsertBreakpointAfter</a>(INST ins, BBL bbl, <a class="code" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> ipoint, <a class="code" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a> order,
      <span class="keyword">const</span> std::string &amp;message)
  {
      <a class="code" href="group__INS__INST__API.html#g952b2b061d3fa8f1cc4d5d59fef53a69">INS_InsertThenCall</a>(ins, ipoint, (AFUNPTR)TriggerBreakpointAfter,
          <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>, order,
          <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d623ad95758bce14fcb9427beef53736a">IARG_INST_PTR</a>, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dadb6e5681193cc8435b9e57d13acf5d4">IARG_THREAD_ID</a>,
          <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d7a11763427dff3afb81caab97b02881b">IARG_PTR</a>, message.c_str(),
          IARG_END);
  }

  VOID TriggerBreakpointAfter(<a class="code" href="group__CONTEXT__API.html#g73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, ADDRINT pc, <a class="code" href="group__PIN__THREAD__API.html#g645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, <span class="keyword">const</span> <span class="keywordtype">char</span> *message)
  {
      std::ostringstream os;
      os &lt;&lt; message &lt;&lt; <span class="stringliteral">"\n"</span>;
      os &lt;&lt; <span class="stringliteral">"Breakpoint triggered after instruction at 0x"</span> &lt;&lt; std::hex &lt;&lt; pc;

      <a class="code" href="group__APPDEBUG__API.html#gd46f50d48ebcf2414e766c2978111c4b">PIN_ApplicationBreakpoint</a>(ctxt, tid, FALSE, os.str());
  }
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>Insert the instrumentation after this instruction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bbl</em>&nbsp;</td><td>The basic block containing <em>ins</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ipoint</em>&nbsp;</td><td>Tells whether to instrument IPOINT_AFTER or IPOINT_TAKEN_BRANCH. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>order</em>&nbsp;</td><td>The instrumentation call order to use for the instrumentation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>String telling why the breakpoint is triggered. The string is allocated in permanent storage, so the client can pass it directly to an analysis routine. If the debugger shell removes instrumentation, it will also deallocate this string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>debugger-shell.H</ul>
<hr size="1"><address style="align: right;"><small>Generated on Mon Apr 8 02:10:54 2013 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
