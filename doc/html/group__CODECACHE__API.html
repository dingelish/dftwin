<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Code Cache API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Code Cache API</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g86684639c3a75bf4fdbf9cc4b600370c">LEVEL_PINCLIENT::CODECACHE_NOARG_CALLBACK</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gb1657b84f0d44af3ac2da0c9142c3170">LEVEL_PINCLIENT::CODECACHE_CACHEBLOCK_CALLBACK</a> (USIZE new_block_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga27eae06435a1c6ece6d5b6a8d598836">LEVEL_PINCLIENT::CODECACHE_FULL_CALLBACK</a> (USIZE trace_size, USIZE stub_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g9ebdb88a092f3b7409ecdd972525c169">LEVEL_PINCLIENT::CODECACHE_ENTEREXIT_CALLBACK</a> (ADDRINT cache_pc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gbef37fccc8e73555688dfa7e2a1a7587">LEVEL_PINCLIENT::CODECACHE_LINKED_CALLBACK</a> (ADDRINT branch_pc, ADDRINT target_pc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gdfaa7ec36f9bc2cdd6f37acbe0eb7f9f">LEVEL_PINCLIENT::CODECACHE_UNLINKED_CALLBACK</a> (ADDRINT branch_pc, ADDRINT stub_pc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g771e9a197494e130032dc6de84fdf92d">LEVEL_PINCLIENT::CODECACHE_TRACEINVALIDATED_CALLBACK</a> (ADDRINT orig_pc, ADDRINT cache_pc, BOOL success)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g818608c3e3d4efee4d3499c6e1df8d10">LEVEL_PINCLIENT::CODECACHE_AddCacheInitFunction</a> (CODECACHE_NOARG_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaed7d3509a81feb381792758af89ac18">LEVEL_PINCLIENT::CODECACHE_AddCacheBlockFunction</a> (CODECACHE_CACHEBLOCK_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g16a21596da23ddd7e8463027f66a0134">LEVEL_PINCLIENT::CODECACHE_AddFullCacheFunction</a> (CODECACHE_FULL_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gdef7979c1ffe2526b256e1eecd116a0f">LEVEL_PINCLIENT::CODECACHE_AddCacheFlushedFunction</a> (CODECACHE_NOARG_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gbed1ea94c5934d1cffbcfcfe09a1bcbe">LEVEL_PINCLIENT::CODECACHE_AddCodeCacheEnteredFunction</a> (CODECACHE_ENTEREXIT_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gb125523cb430986a71858e0768753565">LEVEL_PINCLIENT::CODECACHE_AddCodeCacheExitedFunction</a> (CODECACHE_ENTEREXIT_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gc5310fb42f264cc4c2b874d7b6e3f1de">LEVEL_PINCLIENT::CODECACHE_AddTraceLinkedFunction</a> (CODECACHE_LINKED_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gb4b491a7925e0e1f172b19138c51a395">LEVEL_PINCLIENT::CODECACHE_AddTraceUnlinkedFunction</a> (CODECACHE_UNLINKED_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g6e213a8bb18a2a0704eab23472a07842">LEVEL_PINCLIENT::CODECACHE_AddTraceInvalidatedFunction</a> (CODECACHE_TRACEINVALIDATED_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gf39fec242a10c873fb397f5e3d523ed1">LEVEL_PINCLIENT::CODECACHE_InvalidateTraceAtProgramAddress</a> (ADDRINT app_pc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g54123ca5c5d213041e46c3c47d1030a1">LEVEL_PINCLIENT::CODECACHE_CodeMemReserved</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g285de63369aba24328ddaecd8511e1df">LEVEL_PINCLIENT::CODECACHE_DirectoryMemUsed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g03d298cac03ab619c7d9575ca1bc4408">LEVEL_PINCLIENT::CODECACHE_CodeMemUsed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ge8971f6762d05f83a017263d024db3c5">LEVEL_PINCLIENT::CODECACHE_ExitStubBytes</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g7c8f5165231ddc04eeb2694c58015855">LEVEL_PINCLIENT::CODECACHE_LinkBytes</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga12252f735d860ac0288435c0db72a9b">LEVEL_PINCLIENT::CODECACHE_CacheSizeLimit</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gaf55a4da7c062b4fedb4544d5ef95981">LEVEL_PINCLIENT::CODECACHE_BlockSize</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gbb8af5ba8a4b6f1346ed468811339e4c">LEVEL_PINCLIENT::CODECACHE_NumTracesInCache</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g946dc189f085d5f742be7b0a66db9d2d">LEVEL_PINCLIENT::CODECACHE_NumExitStubsInCache</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ge89e0062f0129394fafae468a6bf8350">LEVEL_PINCLIENT::CODECACHE_CreateNewCacheBlock</a> (USIZE block_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g4a69b3c0ecdbc972c3d79f98491f21d8">LEVEL_PINCLIENT::CODECACHE_ChangeCacheLimit</a> (USIZE cache_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g0ef157780b28486a4757270c00b66108">LEVEL_PINCLIENT::CODECACHE_ChangeBlockSize</a> (USIZE block_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ga057bcb372b7aae955e163e08e38bf82">LEVEL_PINCLIENT::CODECACHE_ChangeMaxInsPerTrace</a> (UINT32 max_ins)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#ge2e1311e142234e705d6f6367b435428">LEVEL_PINCLIENT::CODECACHE_ChangeMaxBblsPerTrace</a> (UINT32 max_basic_blocks)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g3773a88d72d3ceec4c35757e4beb2160">LEVEL_PINCLIENT::CODECACHE_FlushCache</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gb979188050e346d3c01a7de307e9cbe7">LEVEL_PINCLIENT::CODECACHE_InvalidateRange</a> (ADDRINT start, ADDRINT end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ADDRINT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g2442ec5df29c4264fc2b0189ce1e0c2a">LEVEL_PINCLIENT::INS_CodeCacheAddress</a> (INS ins)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ADDRINT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g68e95df926aa9a43fa77283c7c1d409a">LEVEL_PINCLIENT::BBL_CodeCacheAddress</a> (BBL bbl)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ADDRINT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g3649ba022457e9fec1b4b894f161933c">LEVEL_PINCLIENT::TRACE_CodeCacheAddress</a> (TRACE trace)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">USIZE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g6da59177d8a31602356372817ac1c8e2">LEVEL_PINCLIENT::INS_CodeCacheSize</a> (INS ins)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">USIZE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g137cff9c8f26211b79bd129f864bb0a1">LEVEL_PINCLIENT::BBL_CodeCacheSize</a> (BBL bbl)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">USIZE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g16a68b7cb85cdb2a707bf1adb9f4714c">LEVEL_PINCLIENT::TRACE_CodeCacheSize</a> (TRACE trace)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ADDRINT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gbe51bc22d2bd5ced0bc5526cde76f8d9">LEVEL_PINCLIENT::CODECACHE_OriginalAddress</a> (ADDRINT cache_pc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">USIZE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#g85ee054bf89f654d960556d145c600f6">LEVEL_PINCLIENT::PIN_MemoryAllocatedForPin</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CODECACHE__API.html#gd57a8a7b92874d148f837c4b13b0a641">LEVEL_PINCLIENT::CODECACHE_AddTraceInsertedFunction</a> (TRACE_INSTRUMENT_CALLBACK fun, VOID *val)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This API allows the user to inspect Pin's code cache and/or alter the code cache replacement policy. For example, to alter the replacement policy, a user can register a routine that is called anytime the cache is full.<br>
 APIs from this group are available in any thread, including any internal thread spawned by the tool. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="gb1657b84f0d44af3ac2da0c9142c3170"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_CACHEBLOCK_CALLBACK" ref="gb1657b84f0d44af3ac2da0c9142c3170" args="(USIZE new_block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) LEVEL_PINCLIENT::CODECACHE_CACHEBLOCK_CALLBACK(USIZE new_block_size)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when Pin's code cache adds a new cache block 
</div>
</div><p>
<a class="anchor" name="g9ebdb88a092f3b7409ecdd972525c169"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ENTEREXIT_CALLBACK" ref="g9ebdb88a092f3b7409ecdd972525c169" args="(ADDRINT cache_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) LEVEL_PINCLIENT::CODECACHE_ENTEREXIT_CALLBACK(ADDRINT cache_pc)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when control enters or exits code cache 
</div>
</div><p>
<a class="anchor" name="ga27eae06435a1c6ece6d5b6a8d598836"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_FULL_CALLBACK" ref="ga27eae06435a1c6ece6d5b6a8d598836" args="(USIZE trace_size, USIZE stub_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) LEVEL_PINCLIENT::CODECACHE_FULL_CALLBACK(USIZE trace_size, USIZE stub_size)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when Pin's code cache is full 
</div>
</div><p>
<a class="anchor" name="gbef37fccc8e73555688dfa7e2a1a7587"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_LINKED_CALLBACK" ref="gbef37fccc8e73555688dfa7e2a1a7587" args="(ADDRINT branch_pc, ADDRINT target_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) LEVEL_PINCLIENT::CODECACHE_LINKED_CALLBACK(ADDRINT branch_pc, ADDRINT target_pc)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when a trace is linked 
</div>
</div><p>
<a class="anchor" name="g86684639c3a75bf4fdbf9cc4b600370c"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_NOARG_CALLBACK" ref="g86684639c3a75bf4fdbf9cc4b600370c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) LEVEL_PINCLIENT::CODECACHE_NOARG_CALLBACK()          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function that passes no arguments 
</div>
</div><p>
<a class="anchor" name="g771e9a197494e130032dc6de84fdf92d"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_TRACEINVALIDATED_CALLBACK" ref="g771e9a197494e130032dc6de84fdf92d" args="(ADDRINT orig_pc, ADDRINT cache_pc, BOOL success)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) LEVEL_PINCLIENT::CODECACHE_TRACEINVALIDATED_CALLBACK(ADDRINT orig_pc, ADDRINT cache_pc, BOOL success)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when Pin removes a region from the cache 
</div>
</div><p>
<a class="anchor" name="gdfaa7ec36f9bc2cdd6f37acbe0eb7f9f"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_UNLINKED_CALLBACK" ref="gdfaa7ec36f9bc2cdd6f37acbe0eb7f9f" args="(ADDRINT branch_pc, ADDRINT stub_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) LEVEL_PINCLIENT::CODECACHE_UNLINKED_CALLBACK(ADDRINT branch_pc, ADDRINT stub_pc)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function when a trace is unlinked 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g68e95df926aa9a43fa77283c7c1d409a"></a><!-- doxytag: member="LEVEL_PINCLIENT::BBL_CodeCacheAddress" ref="g68e95df926aa9a43fa77283c7c1d409a" args="(BBL bbl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::BBL_CodeCacheAddress           </td>
          <td>(</td>
          <td class="paramtype">BBL&nbsp;</td>
          <td class="paramname"> <em>bbl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine determines the starting code cache address of a basic block (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) <dl class="return" compact><dt><b>Returns:</b></dt><dd>Code Cache Address</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g137cff9c8f26211b79bd129f864bb0a1"></a><!-- doxytag: member="LEVEL_PINCLIENT::BBL_CodeCacheSize" ref="g137cff9c8f26211b79bd129f864bb0a1" args="(BBL bbl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::BBL_CodeCacheSize           </td>
          <td>(</td>
          <td class="paramtype">BBL&nbsp;</td>
          <td class="paramname"> <em>bbl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine determines the code cache footprint of a basic block (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) <dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of the basic block in the code cache</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gaed7d3509a81feb381792758af89ac18"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddCacheBlockFunction" ref="gaed7d3509a81feb381792758af89ac18" args="(CODECACHE_CACHEBLOCK_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddCacheBlockFunction           </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_CACHEBLOCK_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function that gets called whenever a new cache block is formed.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdef7979c1ffe2526b256e1eecd116a0f"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddCacheFlushedFunction" ref="gdef7979c1ffe2526b256e1eecd116a0f" args="(CODECACHE_NOARG_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddCacheFlushedFunction           </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_NOARG_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function that gets called whenever the cache is physically flushed. Note that this event may occur later than the point at which the flush was first requested, either because we were in an analysis routine so it wasn't safe to flush, or because we are running a multithreaded application and we needed to wait for all threads to move out of the traces they were executing before we could flush. (But rest assured that no traces were entered between the time that the flush was requested and when this callback occurs.)<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g818608c3e3d4efee4d3499c6e1df8d10"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddCacheInitFunction" ref="g818608c3e3d4efee4d3499c6e1df8d10" args="(CODECACHE_NOARG_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddCacheInitFunction           </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_NOARG_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function that gets called once, when the code cache is first formed.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbed1ea94c5934d1cffbcfcfe09a1bcbe"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddCodeCacheEnteredFunction" ref="gbed1ea94c5934d1cffbcfcfe09a1bcbe" args="(CODECACHE_ENTEREXIT_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddCodeCacheEnteredFunction           </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_ENTEREXIT_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function that gets called whenever control enters the code cache.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb125523cb430986a71858e0768753565"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddCodeCacheExitedFunction" ref="gb125523cb430986a71858e0768753565" args="(CODECACHE_ENTEREXIT_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddCodeCacheExitedFunction           </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_ENTEREXIT_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function that gets called whenever control exits the code cache.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g16a21596da23ddd7e8463027f66a0134"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddFullCacheFunction" ref="g16a21596da23ddd7e8463027f66a0134" args="(CODECACHE_FULL_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddFullCacheFunction           </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_FULL_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function that gets called whenever the cache fills up.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd57a8a7b92874d148f837c4b13b0a641"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddTraceInsertedFunction" ref="gd57a8a7b92874d148f837c4b13b0a641" args="(TRACE_INSTRUMENT_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddTraceInsertedFunction           </td>
          <td>(</td>
          <td class="paramtype">TRACE_INSTRUMENT_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function that gets called whenever a trace is placed in the code cache.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6e213a8bb18a2a0704eab23472a07842"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddTraceInvalidatedFunction" ref="g6e213a8bb18a2a0704eab23472a07842" args="(CODECACHE_TRACEINVALIDATED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddTraceInvalidatedFunction           </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_TRACEINVALIDATED_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function that gets called whenever a trace is invalidated in the code cache. (This means the trace will never be executed again, but the space is not reclaimed until a full code cache flush.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc5310fb42f264cc4c2b874d7b6e3f1de"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddTraceLinkedFunction" ref="gc5310fb42f264cc4c2b874d7b6e3f1de" args="(CODECACHE_LINKED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddTraceLinkedFunction           </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_LINKED_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function that gets called whenever a trace is linked (backpatched)<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb4b491a7925e0e1f172b19138c51a395"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_AddTraceUnlinkedFunction" ref="gb4b491a7925e0e1f172b19138c51a395" args="(CODECACHE_UNLINKED_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::CODECACHE_AddTraceUnlinkedFunction           </td>
          <td>(</td>
          <td class="paramtype">CODECACHE_UNLINKED_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function that gets called whenever a trace is unlinked (unpatched)<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gaf55a4da7c062b4fedb4544d5ef95981"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_BlockSize" ref="gaf55a4da7c062b4fedb4544d5ef95981" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_BlockSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Default size (in bytes) of code cache allocation units (code cache blocks)</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga12252f735d860ac0288435c0db72a9b"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_CacheSizeLimit" ref="ga12252f735d860ac0288435c0db72a9b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_CacheSizeLimit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Current limit imposed on the memory allowed for storing traces and exit stubs</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0ef157780b28486a4757270c00b66108"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ChangeBlockSize" ref="g0ef157780b28486a4757270c00b66108" args="(USIZE block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeBlockSize           </td>
          <td>(</td>
          <td class="paramtype">USIZE&nbsp;</td>
          <td class="paramname"> <em>block_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_size</em>&nbsp;</td><td>New default size for all future code cache blocks (regions) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on successful change of default cache block size</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4a69b3c0ecdbc972c3d79f98491f21d8"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ChangeCacheLimit" ref="g4a69b3c0ecdbc972c3d79f98491f21d8" args="(USIZE cache_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeCacheLimit           </td>
          <td>(</td>
          <td class="paramtype">USIZE&nbsp;</td>
          <td class="paramname"> <em>cache_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cache_size</em>&nbsp;</td><td>New code cache size limit </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on successful change of max code cache size</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge2e1311e142234e705d6f6367b435428"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ChangeMaxBblsPerTrace" ref="ge2e1311e142234e705d6f6367b435428" args="(UINT32 max_basic_blocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeMaxBblsPerTrace           </td>
          <td>(</td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>max_basic_blocks</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max_basic_blocks</em>&nbsp;</td><td>The new limit of BBs per trace </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on successful change of basic block limit per trace</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga057bcb372b7aae955e163e08e38bf82"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ChangeMaxInsPerTrace" ref="ga057bcb372b7aae955e163e08e38bf82" args="(UINT32 max_ins)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_ChangeMaxInsPerTrace           </td>
          <td>(</td>
          <td class="paramtype">UINT32&nbsp;</td>
          <td class="paramname"> <em>max_ins</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max_ins</em>&nbsp;</td><td>The new limit of instructions per trace </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on successful change of instruction limit per trace</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g54123ca5c5d213041e46c3c47d1030a1"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_CodeMemReserved" ref="g54123ca5c5d213041e46c3c47d1030a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_CodeMemReserved           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Memory size (bytes) reserved for code caching (traces and exit stubs)</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g03d298cac03ab619c7d9575ca1bc4408"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_CodeMemUsed" ref="g03d298cac03ab619c7d9575ca1bc4408" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_CodeMemUsed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Bytes of code cache currently occupied by traces and exit stubs</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge89e0062f0129394fafae468a6bf8350"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_CreateNewCacheBlock" ref="ge89e0062f0129394fafae468a6bf8350" args="(USIZE block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_CreateNewCacheBlock           </td>
          <td>(</td>
          <td class="paramtype">USIZE&nbsp;</td>
          <td class="paramname"> <em>block_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_size</em>&nbsp;</td><td>The size (in bytes) of the new code cache block (region) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on successful generation of a new code cache block</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g285de63369aba24328ddaecd8511e1df"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_DirectoryMemUsed" ref="g285de63369aba24328ddaecd8511e1df" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_DirectoryMemUsed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Memory size (bytes) of the code cache directory data structures Note that this is a lower bound, as it is difficult to get an accurate account for the size of all of the data structures.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge8971f6762d05f83a017263d024db3c5"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_ExitStubBytes" ref="ge8971f6762d05f83a017263d024db3c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_ExitStubBytes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Bytes of code cache currently occupied exit stubs</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3773a88d72d3ceec4c35757e4beb2160"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_FlushCache" ref="g3773a88d72d3ceec4c35757e4beb2160" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::CODECACHE_FlushCache           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine flushes the entire cache. We do not need to remove any links, as they will be flushed with the cache. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Boolean success if the given cache was successfully flushed</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb979188050e346d3c01a7de307e9cbe7"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_InvalidateRange" ref="gb979188050e346d3c01a7de307e9cbe7" args="(ADDRINT start, ADDRINT end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_InvalidateRange           </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine unlinks and invalidates any traces in the code cache that correspond to any code in the given source program address range [start,end] <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The original program starting address of the range we want to invalidate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The original program ending address (inclusive) of the range we want to invalidate </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of Traces Invalidated</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf39fec242a10c873fb397f5e3d523ed1"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_InvalidateTraceAtProgramAddress" ref="gf39fec242a10c873fb397f5e3d523ed1" args="(ADDRINT app_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_InvalidateTraceAtProgramAddress           </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>app_pc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates any traces starting at the given program address. Note: More than one trace may correspond to a single program address due to register allocation <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>app_pc</em>&nbsp;</td><td>The original program address (must be a trace head) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of traces sucessfully invalidated</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7c8f5165231ddc04eeb2694c58015855"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_LinkBytes" ref="g7c8f5165231ddc04eeb2694c58015855" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_LinkBytes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Bytes of cache directory currently occupied by links</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g946dc189f085d5f742be7b0a66db9d2d"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_NumExitStubsInCache" ref="g946dc189f085d5f742be7b0a66db9d2d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_NumExitStubsInCache           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of exit stubs in the entire code cache</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbb8af5ba8a4b6f1346ed468811339e4c"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_NumTracesInCache" ref="gbb8af5ba8a4b6f1346ed468811339e4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::CODECACHE_NumTracesInCache           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of traces in the entire code cache</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbe51bc22d2bd5ced0bc5526cde76f8d9"></a><!-- doxytag: member="LEVEL_PINCLIENT::CODECACHE_OriginalAddress" ref="gbe51bc22d2bd5ced0bc5526cde76f8d9" args="(ADDRINT cache_pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::CODECACHE_OriginalAddress           </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>cache_pc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine returns the original application address associated with the given code cache address. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cache_pc</em>&nbsp;</td><td>The address of the trace in the code cache (any address, not just start of trace) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The original application address if it exists; zero is returned if no application address corresponds with the given code cache address.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2442ec5df29c4264fc2b0189ce1e0c2a"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_CodeCacheAddress" ref="g2442ec5df29c4264fc2b0189ce1e0c2a" args="(INS ins)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::INS_CodeCacheAddress           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine determines the code cache address of any given instruction (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) <dl class="return" compact><dt><b>Returns:</b></dt><dd>Code Cache Address</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6da59177d8a31602356372817ac1c8e2"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_CodeCacheSize" ref="g6da59177d8a31602356372817ac1c8e2" args="(INS ins)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::INS_CodeCacheSize           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine determines the code cache footprint of an instruction (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) <dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of the instrution in the code cache</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g85ee054bf89f654d960556d145c600f6"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_MemoryAllocatedForPin" ref="g85ee054bf89f654d960556d145c600f6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::PIN_MemoryAllocatedForPin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine returns the amount (in bytes) of memory currently allocated by Pin for all internal structures and data. This is an accurate representation tracked through mmap calls. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Bytes of allocated memory</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3649ba022457e9fec1b4b894f161933c"></a><!-- doxytag: member="LEVEL_PINCLIENT::TRACE_CodeCacheAddress" ref="g3649ba022457e9fec1b4b894f161933c" args="(TRACE trace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::TRACE_CodeCacheAddress           </td>
          <td>(</td>
          <td class="paramtype">TRACE&nbsp;</td>
          <td class="paramname"> <em>trace</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine determines the starting code cache address of a trace (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) <dl class="return" compact><dt><b>Returns:</b></dt><dd>Code Cache Address </dd></dl>

</div>
</div><p>
<a class="anchor" name="g16a68b7cb85cdb2a707bf1adb9f4714c"></a><!-- doxytag: member="LEVEL_PINCLIENT::TRACE_CodeCacheSize" ref="g16a68b7cb85cdb2a707bf1adb9f4714c" args="(TRACE trace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::TRACE_CodeCacheSize           </td>
          <td>(</td>
          <td class="paramtype">TRACE&nbsp;</td>
          <td class="paramname"> <em>trace</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine determines the code cache footprint of a trace. If instrumentation is inlined into the trace, the footprint will include that space. (Note: Only valid after code cache space has been allocated for this trace - normally after the instrumentation phase.) <dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of the trace in the code cache</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Apr 8 02:10:54 2013 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
