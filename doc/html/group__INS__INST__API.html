<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Instrumentation API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Instrumentation API<br>
<small>
[<a class="el" href="group__INS__BASIC__API.html">INS: Instruction Object</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#g43c13f7ee260c6717884a6e099fcb952">LEVEL_PINCLIENT::INS_INSTRUMENT_CALLBACK</a> (INS ins, VOID *v)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#g56957614e1271afdd912c485c87fd406">LEVEL_PINCLIENT::INS_AddInstrumentFunction</a> (INS_INSTRUMENT_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#g26d02bff719bf8600421895956804252">LEVEL_PINCLIENT::INS_InsertPredicatedCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> ipoint, AFUNPTR funptr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#g74a956a0acde197043d04f4adcde4626">LEVEL_PINCLIENT::INS_InsertCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#g7907ad8ebd991b9e24df3b3b9cec4cac">LEVEL_PINCLIENT::INS_InsertIfCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#g952b2b061d3fa8f1cc4d5d59fef53a69">LEVEL_PINCLIENT::INS_InsertThenCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#g5009833ffeecd9fecd8f842a605bf2a1">LEVEL_PINCLIENT::INS_InsertIfPredicatedCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#g88f930cbed33fa370c9611cc0183d97b">LEVEL_PINCLIENT::INS_InsertThenPredicatedCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#gcf731514b88f79344068df5d8e60eacc">LEVEL_PINCLIENT::INS_InsertFillBuffer</a> (INS ins, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, BUFFER_ID id,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#g74a3e0d9a1e35568c28abd9b2ba29e4d">LEVEL_PINCLIENT::INS_InsertFillBufferPredicated</a> (INS ins, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, BUFFER_ID id,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#ga4e98a83483b18bf47d20cb99b4c24ec">LEVEL_PINCLIENT::INS_InsertFillBufferThen</a> (INS ins, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, BUFFER_ID id,...)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Use these functions to instrument instructions. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g43c13f7ee260c6717884a6e099fcb952"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_INSTRUMENT_CALLBACK" ref="g43c13f7ee260c6717884a6e099fcb952" args="(INS ins, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) LEVEL_PINCLIENT::INS_INSTRUMENT_CALLBACK(INS ins, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="anchor" name="INS_INSTRUMENT_CALLBACK"></a><p>
Call back function used to instrument instructions 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g56957614e1271afdd912c485c87fd406"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_AddInstrumentFunction" ref="g56957614e1271afdd912c485c87fd406" args="(INS_INSTRUMENT_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_AddInstrumentFunction           </td>
          <td>(</td>
          <td class="paramtype">INS_INSTRUMENT_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a function used to instrument at instruction granularity <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Instrumentation function for instructions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>passed as the second argument to the instrumentation function</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g74a956a0acde197043d04f4adcde4626"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertCall" ref="g74a956a0acde197043d04f4adcde4626" args="(INS ins, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertCall           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a call to funptr relative to instruction ins. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ins</em>&nbsp;</td><td>Instruction to instrument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>Specifies before, after, etc. <br>
 IPOINT_BEFORE is always valid for all instructions. <br>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). <br>
 IPOINT_TAKEN_BRANCH is invalid for non-branches. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>funptr</em>&nbsp;</td><td>Insert a call to funptr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>List of arguments to pass funptr. See <a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>, terminated with IARG_END</td></tr>
  </table>
</dl>
If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gcf731514b88f79344068df5d8e60eacc"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertFillBuffer" ref="gcf731514b88f79344068df5d8e60eacc" args="(INS ins, IPOINT action, BUFFER_ID id,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertFillBuffer           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BUFFER_ID&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert analysis code to fill one record in a trace buffer whenever an application instruction executes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>The application instruction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>action</em>&nbsp;</td><td>Tells whether the record is filled before or after the instruction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the buffer whose record is filled. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>...</em>&nbsp;</td><td><a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. Additional arguments to specify the fields of the trace buffer. These additional arguments take the form: IARG_TYPE arg, [optional IARG parameters], size_t offset, ..., IARG_END The  arg argument specifies the value to write to the trace record field. The  offset argument specifies the offset (in bytes) from the start of the trace record to this field. Typically, you would use "offsetof()" for this. if  arg requires additional parameters, they come before  offset.</td></tr>
  </table>
</dl>
Certain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, and IARG_REG_CONST_REFERENCE.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g74a3e0d9a1e35568c28abd9b2ba29e4d"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertFillBufferPredicated" ref="g74a3e0d9a1e35568c28abd9b2ba29e4d" args="(INS ins, IPOINT action, BUFFER_ID id,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertFillBufferPredicated           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BUFFER_ID&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert analysis code to fill one record in a trace buffer whenever an application instruction executes, based on that instruction's predicate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>The application instruction </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>action</em>&nbsp;</td><td>Whether the record is filled before or after the instruction </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the buffer whose record is filled </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>...</em>&nbsp;</td><td><a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. Additional arguments to specify the fields of the trace buffer.</td></tr>
  </table>
</dl>
Certain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, and IARG_REG_CONST_REFERENCE.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga4e98a83483b18bf47d20cb99b4c24ec"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertFillBufferThen" ref="ga4e98a83483b18bf47d20cb99b4c24ec" args="(INS ins, IPOINT action, BUFFER_ID id,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertFillBufferThen           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BUFFER_ID&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert analysis code to fill one record in a trace buffer whenever an application instruction executes. The record is only inserted if the preceding "if" analysis call returns a non-zero value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>The application instruction </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>action</em>&nbsp;</td><td>Whether the record is filled before or after the instruction </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the buffer whose record is to filled </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>...</em>&nbsp;</td><td><a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. Additional arguments to specify the fields of the trace buffer.</td></tr>
  </table>
</dl>
Certain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, and IARG_REG_CONST_REFERENCE.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7907ad8ebd991b9e24df3b3b9cec4cac"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertIfCall" ref="g7907ad8ebd991b9e24df3b3b9cec4cac" args="(INS ins, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertIfCall           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a call to funptr relative to an INS. If funptr returns a non-zero ADDRINT, then the immediately following "then" analysis call is executed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ins</em>&nbsp;</td><td>Instruction to instrument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>Specifies before, after, etc. <br>
 IPOINT_BEFORE is always valid for all instructions. <br>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). <br>
 IPOINT_TAKEN_BRANCH is invalid for non-branches. <br>
 IPOINT_ANYWHERE is not supported and will result an error. <br>
 action value must be identical to the value passed to the corresponding INS_InsertThenCall. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>funptr</em>&nbsp;</td><td>Insert a call to funptr. Its return type must be ADDRINT </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>List of arguments to pass funptr. See <a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>, terminated with IARG_END</td></tr>
  </table>
</dl>
If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5009833ffeecd9fecd8f842a605bf2a1"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertIfPredicatedCall" ref="g5009833ffeecd9fecd8f842a605bf2a1" args="(INS ins, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertIfPredicatedCall           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a call to funptr relative to an INS. If funptr returns a non-zero ADDRINT and the instruction has a true predicate, then the immediately following "then" analysis call is executed. If the instruction is not predicated, then this function is identical to INS_InsertIfCall.<p>
Note that funptr <em>may</em> be called even if the predicate is false, the predicate is only defined to guard the execution of the following THEN function. (So if the function inserted here modifies the machine state it might affect the value of the predicate. Best practice is not to modify machine state here!)<p>
On IA32 and Intel64, the sequences <div class="fragment"><pre class="fragment">     <a class="code" href="group__INS__INST__API.html#g7907ad8ebd991b9e24df3b3b9cec4cac">INS_InsertIfCall</a>(...);
     <a class="code" href="group__INS__INST__API.html#g88f930cbed33fa370c9611cc0183d97b">INS_InsertThenPredicatedCall</a>(...);
</pre></div> <div class="fragment"><pre class="fragment">     <a class="code" href="group__INS__INST__API.html#g5009833ffeecd9fecd8f842a605bf2a1">INS_InsertIfPredicatedCall</a>(...);
     <a class="code" href="group__INS__INST__API.html#g952b2b061d3fa8f1cc4d5d59fef53a69">INS_InsertThenCall</a>(...);
</pre></div> and <div class="fragment"><pre class="fragment">     <a class="code" href="group__INS__INST__API.html#g5009833ffeecd9fecd8f842a605bf2a1">INS_InsertIfPredicatedCall</a>(...);
     <a class="code" href="group__INS__INST__API.html#g88f930cbed33fa370c9611cc0183d97b">INS_InsertThenPredicatedCall</a>(...);
</pre></div><p>
produce identical results. They all generate code which can be represented like this <div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (UsersIfFunction(...))
          <span class="keywordflow">if</span> (predicate)
              UsersThenFunction(...);
</pre></div> However on other architectures the behavior may be different, and the "IF" call need not always be called.<p>
This means that on IA32 and Intel64 the user's IF code is always called, however on these architectures that is very likely to generate faster code, since predicated instructions are rare. The dynamically most important predicated instructions are almost certainly REP MOVS, which have a very low (~80ppm) probablity of being predicated false. Unless the user's IF code is very large, or has a lower probability of filtering the execution, it is always better to use the test of the user condition to prevent execution of the predicate test. Of course, the code included in a user IF call is expected to be small, since the objective of INS_InsertIfCall, INS_InsertThenCall is to allow the code in the IF to be inlined.<p>
If you need to know the instruction predicate inside the IF call, you should pass IARG_EXECUTING as an argument and test it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ins</em>&nbsp;</td><td>Instruction to instrument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>Specifies before, after, etc. <br>
 <a class="el" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a> is always valid for all instructions. <br>
 <a class="el" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad742eff26179c6d87348abe492301c12ec">IPOINT_AFTER</a> is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). <br>
 <a class="el" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad75ef5b45901a8447e5173f50746ab029d">IPOINT_TAKEN_BRANCH</a> is invalid for non-branches. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>funptr</em>&nbsp;</td><td>Insert a call to funptr. Its return type must be ADDRINT </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>List of arguments to pass funptr. See <a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>, terminated with IARG_END</td></tr>
  </table>
</dl>
If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g26d02bff719bf8600421895956804252"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertPredicatedCall" ref="g26d02bff719bf8600421895956804252" args="(INS ins, IPOINT ipoint, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertPredicatedCall           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>ipoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See INS_InsertCall. When the instruction has a predicate and the predicate is false, the analysis function is not called.<p>
On the IA-32 and Intel 64 architectures the only instructions treated as predicated are CMOVcc, FCMOVcc and REPped string ops. For the conditional moves, the predicate is based on the condition codes tested by the instruction. For the REPped string ops the predicate is that the execution count is not zero. For all other instructions the predicate is always true, so INS_InsertPredicatedCall is identical to INS_InsertCall.<p>
If you want to test both your own condition, and the predicate, you can use INS_InsertThenPredicatedCall, or use <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d5f291cb55a7d61a40fa3ab98e191394e">IARG_EXECUTING</a> to pass the predicate value to an INS_InsertIfCall.<p>
If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g952b2b061d3fa8f1cc4d5d59fef53a69"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertThenCall" ref="g952b2b061d3fa8f1cc4d5d59fef53a69" args="(INS ins, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertThenCall           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a call to funptr relative to an INS. The function is called only if the immediately preceding "if" analysis call returns a non-zero value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ins</em>&nbsp;</td><td>Instruction to instrument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>Specifies before, after, etc. <br>
 IPOINT_BEFORE is always valid for all instructions. <br>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). <br>
 IPOINT_TAKEN_BRANCH is invalid for non-branches. <br>
 IPOINT_ANYWHERE is not supported and will result an error. <br>
 action value must be identical to the value passed to the corresponding INS_InsertIfCall. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>funptr</em>&nbsp;</td><td>Insert a call to funptr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>List of arguments to pass funptr. See <a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>, terminated with IARG_END</td></tr>
  </table>
</dl>
If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g88f930cbed33fa370c9611cc0183d97b"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertThenPredicatedCall" ref="g88f930cbed33fa370c9611cc0183d97b" args="(INS ins, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertThenPredicatedCall           </td>
          <td>(</td>
          <td class="paramtype">INS&nbsp;</td>
          <td class="paramname"> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a call to funptr relative to an INS. The function is called only if the immediately preceding "if" analysis call returns a non-zero value and the instruction's predicate is true. See INS_InsertIfPredicatedCall for details of the semantics of mixing INS_InsertThenPredicatedCall with INS_InsertIfCall (and all the other possibilities).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ins</em>&nbsp;</td><td>Instruction to instrument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>Specifies before, after, etc. <br>
 IPOINT_BEFORE is always valid for all instructions. <br>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). <br>
 IPOINT_TAKEN_BRANCH is invalid for non-branches. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>funptr</em>&nbsp;</td><td>Insert a call to funptr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>List of arguments to pass funptr. See <a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>, terminated with IARG_END</td></tr>
  </table>
</dl>
If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#g3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Apr 8 02:10:54 2013 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
