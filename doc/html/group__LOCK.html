<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: LOCK: Locking Primitives</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>LOCK: Locking Primitives</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef PINVM::PINSYNC_POD_LOCK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g973e1a7aa00c2222b78a2d929942aa26">LEVEL_BASE::PIN_MUTEX</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef PINVM::PINSYNC_POD_RWLOCK&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g1a83b34b05b377bfe003e5dc6b3bd538">LEVEL_BASE::PIN_RWMUTEX</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef PINVM::PINSYNC_POD_SEMAPHORE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gcb5ef8f4cc82a8c52b76d4b36833efc9">LEVEL_BASE::PIN_SEMAPHORE</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gfa913809147d46f95700a6d8da429c61">LEVEL_BASE::InitLock</a> (PIN_LOCK *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gcb584611ae773c582d79d075adbe9bee">LEVEL_BASE::GetLock</a> (PIN_LOCK *lock, INT32 val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">INT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gc4cc0b427595083dc54e00e7e82bf355">LEVEL_BASE::ReleaseLock</a> (PIN_LOCK *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g3eac779ad4b2b25354c32e38e686bc23">LEVEL_BASE::PIN_MutexInit</a> (PIN_MUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g1ca0f0677773ec5226046f7080c7b80a">LEVEL_BASE::PIN_MutexFini</a> (PIN_MUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g06e1dcf8be9ec221b3a33a088442a258">LEVEL_BASE::PIN_MutexLock</a> (PIN_MUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gd4064bee5097081f70bcffada288ad64">LEVEL_BASE::PIN_MutexUnlock</a> (PIN_MUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g63a86610b3fcfe706d9f9b4b994edc8f">LEVEL_BASE::PIN_MutexTryLock</a> (PIN_MUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g5b92967aad8917bdc98073d49e1caf05">LEVEL_BASE::PIN_RWMutexInit</a> (PIN_RWMUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g6249bae3e5c0c5e3307c8dde2900f027">LEVEL_BASE::PIN_RWMutexFini</a> (PIN_RWMUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gfff39c1f90566f685e830e11683d7c43">LEVEL_BASE::PIN_RWMutexReadLock</a> (PIN_RWMUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gfb7a7e751583ee713fd347947cfeb9ea">LEVEL_BASE::PIN_RWMutexWriteLock</a> (PIN_RWMUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g6bf81704640b5afcfcd8e453d2b3cdcb">LEVEL_BASE::PIN_RWMutexUnlock</a> (PIN_RWMUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gc1b85d26ca88af1f08001fd9ce165ad8">LEVEL_BASE::PIN_RWMutexTryReadLock</a> (PIN_RWMUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ge23e9dac1682bb5619fc17aab2d9f559">LEVEL_BASE::PIN_RWMutexTryWriteLock</a> (PIN_RWMUTEX *lock)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g97c7eb94b7760217207942ff8543e564">LEVEL_BASE::PIN_SemaphoreInit</a> (PIN_SEMAPHORE *sem)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g3412764276afe79a4d1c1df35b002072">LEVEL_BASE::PIN_SemaphoreFini</a> (PIN_SEMAPHORE *sem)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g163634b37634a6361cff1dda18dc44a2">LEVEL_BASE::PIN_SemaphoreSet</a> (PIN_SEMAPHORE *sem)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gb3ed7bfbf6350e0b3465d09965964d00">LEVEL_BASE::PIN_SemaphoreClear</a> (PIN_SEMAPHORE *sem)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g2c63e8b3caf64837802c393277f3cd2d">LEVEL_BASE::PIN_SemaphoreIsSet</a> (PIN_SEMAPHORE *sem)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga15d7ac33e2f14bce0540d31ba7247fe">LEVEL_BASE::PIN_SemaphoreWait</a> (PIN_SEMAPHORE *sem)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#g091e4cf3a2aa0b07e811bd7ade613b6a">LEVEL_BASE::PIN_SemaphoreTimedWait</a> (PIN_SEMAPHORE *sem, unsigned timeout)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Primitives for locking.<br>
 APIs from this group are available in any thread, including any internal thread spawned by the tool.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g973e1a7aa00c2222b78a2d929942aa26"></a><!-- doxytag: member="LEVEL_BASE::PIN_MUTEX" ref="g973e1a7aa00c2222b78a2d929942aa26" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PINVM::PINSYNC_POD_LOCK LEVEL_BASE::PIN_MUTEX          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A simple non-recursive lock. PIN_MUTEX is different from PIN_LOCK because it provides just mutex locking without an extra "lock owner" parameter. 
</div>
</div><p>
<a class="anchor" name="g1a83b34b05b377bfe003e5dc6b3bd538"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMUTEX" ref="g1a83b34b05b377bfe003e5dc6b3bd538" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PINVM::PINSYNC_POD_RWLOCK LEVEL_BASE::PIN_RWMUTEX          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A non-recursive multiple-reader / single-writer lock. Use this lock when multiple "reader" threads can simultaneously access a shared resource, but "writer" threads need to have exclusive access. This is a write-biased lock: if a writer thread blocks on the lock because there are active readers, new readers are prevented from acquiring the lock until the writer gets access. This prevents starvation of writer threads. 
</div>
</div><p>
<a class="anchor" name="gcb5ef8f4cc82a8c52b76d4b36833efc9"></a><!-- doxytag: member="LEVEL_BASE::PIN_SEMAPHORE" ref="gcb5ef8f4cc82a8c52b76d4b36833efc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PINVM::PINSYNC_POD_SEMAPHORE LEVEL_BASE::PIN_SEMAPHORE          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A binary semaphore synchronization object. You can use this synchronization when one thread needs to wait for some condition to become true. A binary semaphore has exactly two states: "set" and "clear". It is possible for one or more threads to wait for the semaphore to become "set". Those threads resume when some other thread changes the state to "set".<p>
Note that it is generally not safe to wait on a PIN_SEMAPHORE from an analysis routine or from a call-back function. Most Pin call-back functions are called while Pin holds an internal lock (the VM lock). Therefore, if you wait on a PIN_SEMAPHORE from a call-back, you will prevent any other thread from entering any call-back function (because the waiting thread also holds the VM lock). There is also a danger when waiting on a PIN_SEMAPHORE from an analysis routine. If a thread waits on a semaphore from an analysis routine, the application may also hold some locks of its own. Thus, you can cause a deadlock in the application if you wait on a semaphore while the application holds its own lock.<p>
The dangers listed above do not exist if you wait on a PIN_SEMAPHORE from a Pin internal thread (see <a class="el" href="group__PIN__THREAD__API.html#ge5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a>). Also, it is safe to set, clear, or test a semaphore from any thread, even when executing an analysis routine or call-back function. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gcb584611ae773c582d79d075adbe9bee"></a><!-- doxytag: member="LEVEL_BASE::GetLock" ref="gcb584611ae773c582d79d075adbe9bee" args="(PIN_LOCK *lock, INT32 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::GetLock           </td>
          <td>(</td>
          <td class="paramtype">PIN_LOCK *&nbsp;</td>
          <td class="paramname"> <em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquire the lock.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Used for debugging. Typically, this is the ID of the calling thread. See the <em>_owner</em> field of PIN_LOCK. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gfa913809147d46f95700a6d8da429c61"></a><!-- doxytag: member="LEVEL_BASE::InitLock" ref="gfa913809147d46f95700a6d8da429c61" args="(PIN_LOCK *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::InitLock           </td>
          <td>(</td>
          <td class="paramtype">PIN_LOCK *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the lock as free<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable to initialize. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g1ca0f0677773ec5226046f7080c7b80a"></a><!-- doxytag: member="LEVEL_BASE::PIN_MutexFini" ref="g1ca0f0677773ec5226046f7080c7b80a" args="(PIN_MUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_MutexFini           </td>
          <td>(</td>
          <td class="paramtype">PIN_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy the PIN_MUTEX and deallocate resources. If you want to use the lock object again later, you must call <a class="el" href="group__LOCK.html#g3eac779ad4b2b25354c32e38e686bc23">PIN_MutexInit()</a> again.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g3eac779ad4b2b25354c32e38e686bc23"></a><!-- doxytag: member="LEVEL_BASE::PIN_MutexInit" ref="g3eac779ad4b2b25354c32e38e686bc23" args="(PIN_MUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_MutexInit           </td>
          <td>(</td>
          <td class="paramtype">PIN_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function must be called to initialize a PIN_MUTEX before it is used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE on successful initialization. If FALSE is returned, initialization failed, and the PIN_MUTEX may not be used. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g06e1dcf8be9ec221b3a33a088442a258"></a><!-- doxytag: member="LEVEL_BASE::PIN_MutexLock" ref="g06e1dcf8be9ec221b3a33a088442a258" args="(PIN_MUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_MutexLock           </td>
          <td>(</td>
          <td class="paramtype">PIN_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Block the caller until the lock can be acquired.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g63a86610b3fcfe706d9f9b4b994edc8f"></a><!-- doxytag: member="LEVEL_BASE::PIN_MutexTryLock" ref="g63a86610b3fcfe706d9f9b4b994edc8f" args="(PIN_MUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_MutexTryLock           </td>
          <td>(</td>
          <td class="paramtype">PIN_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Try to acquire the lock, but do not block the caller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the lock is acquired, FALSE if not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd4064bee5097081f70bcffada288ad64"></a><!-- doxytag: member="LEVEL_BASE::PIN_MutexUnlock" ref="gd4064bee5097081f70bcffada288ad64" args="(PIN_MUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_MutexUnlock           </td>
          <td>(</td>
          <td class="paramtype">PIN_MUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release the lock.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6249bae3e5c0c5e3307c8dde2900f027"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexFini" ref="g6249bae3e5c0c5e3307c8dde2900f027" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_RWMutexFini           </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy the PIN_RWMUTEX and deallocate resources. If you want to use the lock object again later, you must call <a class="el" href="group__LOCK.html#g5b92967aad8917bdc98073d49e1caf05">PIN_RWMutexInit()</a> again.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g5b92967aad8917bdc98073d49e1caf05"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexInit" ref="g5b92967aad8917bdc98073d49e1caf05" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_RWMutexInit           </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function must be called to initialize a PIN_RWMUTEX before it is used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE on successful initialization. If FALSE is returned, initialization failed, and the PIN_RWMUTEX may not be used. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfff39c1f90566f685e830e11683d7c43"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexReadLock" ref="gfff39c1f90566f685e830e11683d7c43" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_RWMutexReadLock           </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquire the lock for "read" access, blocking if necessary. Multiple readers may simultaneously hold the same lock.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gc1b85d26ca88af1f08001fd9ce165ad8"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexTryReadLock" ref="gc1b85d26ca88af1f08001fd9ce165ad8" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_RWMutexTryReadLock           </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to acquire the lock as a reader, but does not block the caller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the lock is acquired, FALSE if not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge23e9dac1682bb5619fc17aab2d9f559"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexTryWriteLock" ref="ge23e9dac1682bb5619fc17aab2d9f559" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_RWMutexTryWriteLock           </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to acquire the lock as a writer, but does not block the caller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the lock is acquired, FALSE if not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6bf81704640b5afcfcd8e453d2b3cdcb"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexUnlock" ref="g6bf81704640b5afcfcd8e453d2b3cdcb" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_RWMutexUnlock           </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release the lock. Used for both "readers" and "writers".<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gfb7a7e751583ee713fd347947cfeb9ea"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexWriteLock" ref="gfb7a7e751583ee713fd347947cfeb9ea" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_RWMutexWriteLock           </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquire the lock for "write" access, blocking if necessary. A writer has exclusive ownership of the lock, not shared with any other readers or writers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb3ed7bfbf6350e0b3465d09965964d00"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreClear" ref="gb3ed7bfbf6350e0b3465d09965964d00" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_SemaphoreClear           </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&nbsp;</td>
          <td class="paramname"> <em>sem</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change the semaphore's state to "clear". This has no effect on any threads waiting on the semaphore.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>The semaphore variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g3412764276afe79a4d1c1df35b002072"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreFini" ref="g3412764276afe79a4d1c1df35b002072" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_SemaphoreFini           </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&nbsp;</td>
          <td class="paramname"> <em>sem</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy the PIN_SEMAPHORE and deallocate resources. If you want to use the lock object again later, you must call <a class="el" href="group__LOCK.html#g97c7eb94b7760217207942ff8543e564">PIN_SemaphoreInit()</a> again.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>The semaphore variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g97c7eb94b7760217207942ff8543e564"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreInit" ref="g97c7eb94b7760217207942ff8543e564" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_SemaphoreInit           </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&nbsp;</td>
          <td class="paramname"> <em>sem</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function must be called to initialize a PIN_SEMAPHORE before it is used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>The semaphore variable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE on successful initialization. If FALSE is returned, initialization failed, and the PIN_SEMAPHORE may not be used. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2c63e8b3caf64837802c393277f3cd2d"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreIsSet" ref="g2c63e8b3caf64837802c393277f3cd2d" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_SemaphoreIsSet           </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&nbsp;</td>
          <td class="paramname"> <em>sem</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check whether the semaphore's state is "set", but do not block.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>The semaphore variable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the semaphore's state is "set". </dd></dl>

</div>
</div><p>
<a class="anchor" name="g163634b37634a6361cff1dda18dc44a2"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreSet" ref="g163634b37634a6361cff1dda18dc44a2" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_SemaphoreSet           </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&nbsp;</td>
          <td class="paramname"> <em>sem</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change the semaphore's state to "set" and tell any threads waiting on the semaphore to wake up. Note that threads waiting on the semaphore may not resume running right away, and they are guaranteed to resume only if the semaphore's state is still "set" when they actually do resume.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>The semaphore variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g091e4cf3a2aa0b07e811bd7ade613b6a"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreTimedWait" ref="g091e4cf3a2aa0b07e811bd7ade613b6a" args="(PIN_SEMAPHORE *sem, unsigned timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_SemaphoreTimedWait           </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&nbsp;</td>
          <td class="paramname"> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Block the calling thread until the semaphore's state is "set" or until a timeout expires. The calling thread resumes immediately if the state is already "set".<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>The semaphore variable. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout period (milliseconds).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the semaphore's state is "set", FALSE if this method returns due to the timeout. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga15d7ac33e2f14bce0540d31ba7247fe"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreWait" ref="ga15d7ac33e2f14bce0540d31ba7247fe" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_SemaphoreWait           </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&nbsp;</td>
          <td class="paramname"> <em>sem</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Block the calling thread until the semaphore's state is "set". The calling thread resumes immediately if the state is already "set".<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>The semaphore variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gc4cc0b427595083dc54e00e7e82bf355"></a><!-- doxytag: member="LEVEL_BASE::ReleaseLock" ref="gc4cc0b427595083dc54e00e7e82bf355" args="(PIN_LOCK *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 LEVEL_BASE::ReleaseLock           </td>
          <td>(</td>
          <td class="paramtype">PIN_LOCK *&nbsp;</td>
          <td class="paramname"> <em>lock</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release the lock.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lock</em>&nbsp;</td><td>The lock variable.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <em>val</em> parameter that was passed to <a class="el" href="group__LOCK.html#gcb584611ae773c582d79d075adbe9bee">GetLock()</a> when the lock was acquired. Typically, this is the ID of the thread that owned the lock. </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Apr 8 02:10:54 2013 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
