<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: RTN: Routine Object</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>RTN: Routine Object</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gb4ebec25363b9af70725ac8f6b536af2">LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACK</a> (RTN rtn, VOID *v)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gabed1675b61b2375c45d3b9e157a15bf">LEVEL_PINCLIENT::PROBE_MODE</a> { <br>
&nbsp;&nbsp;<b>PROBE_MODE_DEFAULT</b> =  0, 
<br>
&nbsp;&nbsp;<b>PROBE_MODE_ALLOW_RELOCATION</b> =  (1&lt;&lt;0)
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SEC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g4883c839d424578a9f6983d05e6a9a12">LEVEL_PINCLIENT::RTN_Sec</a> (RTN x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RTN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g491bf55c9718f8751054ebe37b460d65">LEVEL_PINCLIENT::RTN_Next</a> (RTN x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RTN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gd8d3497e9c27305ba5e9e77e169996ac">LEVEL_PINCLIENT::RTN_Prev</a> (RTN x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RTN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g8499bc83ee010e62a121237ee277224d">LEVEL_PINCLIENT::RTN_Invalid</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g6ac855c9a19a3aab44347188e6695875">LEVEL_PINCLIENT::RTN_Valid</a> (RTN x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gf9d9689a59240ecc29c80d584f268c72">LEVEL_PINCLIENT::RTN_Name</a> (RTN x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SYM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gf0bc95e4eccdcd11cf9b3033a0d5ba78">LEVEL_PINCLIENT::RTN_Sym</a> (RTN x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">AFUNPTR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g039af36fbf3aa4014f30ff8c31b41f9a">LEVEL_PINCLIENT::RTN_Funptr</a> (RTN x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">INT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gb3b1f7eeb5a5a8b91a18f2cca866c78c">LEVEL_PINCLIENT::RTN_Id</a> (RTN x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g1208c26573e12bec41d7ffa026dd3089">LEVEL_PINCLIENT::RTN_AddInstrumentFunction</a> (RTN_INSTRUMENT_CALLBACK fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">USIZE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g3a60bd22473cbf464bca49b3390c79bb">LEVEL_PINCLIENT::RTN_Range</a> (RTN rtn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">USIZE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g5a80e8ef7b6d02902b07ca889f4b5b35">LEVEL_PINCLIENT::RTN_Size</a> (RTN rtn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g46d422d71d917e2cd7cd374c10804341">LEVEL_PINCLIENT::RTN_FindNameByAddress</a> (ADDRINT address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RTN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g6f86e6509f4bddb238576cda772c15de">LEVEL_PINCLIENT::RTN_FindByAddress</a> (ADDRINT address)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RTN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g77a2ad03e0431b881d6c3019b45261eb">LEVEL_PINCLIENT::RTN_FindByName</a> (IMG img, const CHAR *name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gf8714086f8aebc9feacccc8cd02dc561">LEVEL_PINCLIENT::RTN_Open</a> (RTN rtn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g37272253377eb65c9eb5ff47ec4f1e6b">LEVEL_PINCLIENT::RTN_Close</a> (RTN rtn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">INS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gb1bd91206939b88057664c46ef8eac86">LEVEL_PINCLIENT::RTN_InsHead</a> (RTN rtn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">INS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g2ff7a2210bc42f9367635f0bf30b24cb">LEVEL_PINCLIENT::RTN_InsHeadOnly</a> (RTN rtn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">INS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gab13f04ab2dcb762c79aea42c5aef69d">LEVEL_PINCLIENT::RTN_InsTail</a> (RTN rtn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UINT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g540e1cb6a6c696d3da538abd5e369fc5">LEVEL_PINCLIENT::RTN_NumIns</a> (RTN rtn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g76bde295a78d1232fd6ff98a5ff011cf">LEVEL_PINCLIENT::RTN_InsertCall</a> (RTN rtn, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ADDRINT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g83a81fae96c9faabe0f1c90a0d7e865f">LEVEL_PINCLIENT::RTN_Address</a> (RTN rtn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RTN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#ga6c9c5c444bffe61f7a37cb478517eff">LEVEL_PINCLIENT::RTN_CreateAt</a> (ADDRINT address, string name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gc62efd410a5a59fcff516657a53bcf56">LEVEL_PINCLIENT::DeleteRtnCheckHistory</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g5133c810a48e94f566fecc2c11eb1f50">LEVEL_PINCLIENT::RTN_IsSafeForProbedInsertion</a> (RTN rtn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gac635416e3b16a25d8bb9d157979bde4">LEVEL_PINCLIENT::RTN_IsSafeForProbedInsertionEx</a> (RTN rtn, PROBE_MODE mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g7e153406e2ff0031186ea67d9da1e2d7">LEVEL_PINCLIENT::RTN_IsSafeForProbedReplacement</a> (RTN rtn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gaccf66a3919efb9807dbd86bcb4ec36a">LEVEL_PINCLIENT::RTN_IsSafeForProbedReplacementEx</a> (RTN rtn, PROBE_MODE mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">AFUNPTR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gec56561cab520a5493a599800319447b">LEVEL_PINCLIENT::RTN_ReplaceSignatureProbed</a> (RTN replacedRtn, AFUNPTR replacementFun,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">AFUNPTR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#gae095733d136989fd0ebf49546758c65">LEVEL_PINCLIENT::RTN_ReplaceSignatureProbedEx</a> (RTN replacedRtn, PROBE_MODE mode, AFUNPTR replacementFun,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g8654a9e07644e5f6a73db1abea0899a7">LEVEL_PINCLIENT::RTN_InsertCallProbed</a> (RTN orgRtn, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g77f0894505803bbae6da71ee1f3a3781">LEVEL_PINCLIENT::RTN_InsertCallProbedEx</a> (RTN orgRtn, <a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, PROBE_MODE mode, AFUNPTR funptr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">INT32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g8903109ba2b31277e60c7225e74120b3">LEVEL_PINCLIENT::RTN_CodeRangesProbed</a> (RTN rtn, INT32 num, <a class="el" href="structPIN__CODE__RANGE.html">PIN_CODE_RANGE</a> *buffer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">AFUNPTR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g64940153e16fee5bd143a95bdf67c5af">LEVEL_PINCLIENT::RTN_Replace</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">AFUNPTR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g2dcaf2242c7a62151d89c01e2f04f8c0">LEVEL_PINCLIENT::RTN_ReplaceSignature</a> (RTN replacedRtn, AFUNPTR replacementFun,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">AFUNPTR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g63500925719539624424cd62a8d027f9">LEVEL_PINCLIENT::RTN_ReplaceProbed</a> (RTN replacedRtn, AFUNPTR replacementFun)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">AFUNPTR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RTN__BASIC__API.html#g935f735a52675d54fdb5a40b99de2026">LEVEL_PINCLIENT::RTN_ReplaceProbedEx</a> (RTN replacedRtn, PROBE_MODE mode, AFUNPTR replacementFun)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A RTN represents the functions/routines/procedures typically produced by a compiler for a procedural programming language such as C. Pin finds routines by using the symbol table information. You must call <a class="el" href="group__PIN__CONTROL.html#g8cf4aca0b0bdbc7fc0ae965883d8e3c2">PIN_InitSymbols()</a> so that symbol table information will be available. Can be accessed at instrumentation time and analysis time.<br>
 APIs from this group are available in any thread, including any internal thread spawned by the tool.<p>
Iteration idioms:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Forward pass over all routines in a section</span>
  <span class="keywordflow">for</span>( RTN rtn= <a class="code" href="group__SEC__BASIC__API.html#g6b132c297092644f83681f005b087e24">SEC_RtnHead</a>(sec); <a class="code" href="group__RTN__BASIC__API.html#g6ac855c9a19a3aab44347188e6695875">RTN_Valid</a>(rtn); rtn = <a class="code" href="group__RTN__BASIC__API.html#g491bf55c9718f8751054ebe37b460d65">RTN_Next</a>(rtn) )

  <span class="comment">// Reverse pass over all routines in a section</span>
  <span class="keywordflow">for</span>( RTN rtn= <a class="code" href="group__SEC__BASIC__API.html#g399683e8a9a2fc2a9468080cf4095516">SEC_RtnTail</a>(sec); <a class="code" href="group__RTN__BASIC__API.html#g6ac855c9a19a3aab44347188e6695875">RTN_Valid</a>(rtn); rtn = <a class="code" href="group__RTN__BASIC__API.html#gd8d3497e9c27305ba5e9e77e169996ac">RTN_Prev</a>(rtn) )
</pre></div> <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="gb4ebec25363b9af70725ac8f6b536af2"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACK" ref="gb4ebec25363b9af70725ac8f6b536af2" args="(RTN rtn, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(*) LEVEL_PINCLIENT::RTN_INSTRUMENT_CALLBACK(RTN rtn, VOID *v)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call back function used to instrument routines 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="gabed1675b61b2375c45d3b9e157a15bf"></a><!-- doxytag: member="LEVEL_PINCLIENT::PROBE_MODE" ref="gabed1675b61b2375c45d3b9e157a15bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__RTN__BASIC__API.html#gabed1675b61b2375c45d3b9e157a15bf">LEVEL_PINCLIENT::PROBE_MODE</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
PROBE_MODE enumerator allows user to set probe mode instrumentation other than default for a particular function. Usually, non-default mode is used when Pin can't instrument a routine in a regular way. A non default mode is usually less safe and tool-writer takes responsibility for correctness in this case.<p>
PROBE_MODE_ALLOW_RELOCATION<p>
Doing probed instrumentation Pin inserts a jumper in the first bytes of the instrumented routine. If the first basic block calculated within static discovery is not long enough, Pin can't insert a jumper and the instrumentation request is rejected. One more chance to insert a jumper in such case is to relocate the whole routine. It is not always possible, of course. The routine can be relocated by Pin if<ul>
<li>the size is known</li><li>there is no jumps outside function and</li><li>the routine does not contain indirect jumps</li></ul>
<p>
The routine relocation may destabilize the application since ability to propagate exceptions is not preserved. Doing static analysis Pin also does not see additional entry points in the routine code.<p>
In PROBE_MODE_ALLOW_RELOCATION mode Pin tries to keep the instrumented routine in place, and considers relocation when "in-place" instrumentation is impossible. In PROBE_MODE_DEFAULT the relocation is not allowed. Routine relocation is not supported on Windows and IA-64. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gc62efd410a5a59fcff516657a53bcf56"></a><!-- doxytag: member="LEVEL_PINCLIENT::DeleteRtnCheckHistory" ref="gc62efd410a5a59fcff516657a53bcf56" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::DeleteRtnCheckHistory           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear history of routine check 
</div>
</div><p>
<a class="anchor" name="g1208c26573e12bec41d7ffa026dd3089"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_AddInstrumentFunction" ref="g1208c26573e12bec41d7ffa026dd3089" args="(RTN_INSTRUMENT_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::RTN_AddInstrumentFunction           </td>
          <td>(</td>
          <td class="paramtype">RTN_INSTRUMENT_CALLBACK&nbsp;</td>
          <td class="paramname"> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a function used to instrument at routine granularity <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Instrumentation function for routines </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Passed as the second argument to the instrumentation function</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g83a81fae96c9faabe0f1c90a0d7e865f"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Address" ref="g83a81fae96c9faabe0f1c90a0d7e865f" args="(RTN rtn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT LEVEL_PINCLIENT::RTN_Address           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Address in memory of rtn</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g37272253377eb65c9eb5ff47ec4f1e6b"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Close" ref="g37272253377eb65c9eb5ff47ec4f1e6b" args="(RTN rtn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::RTN_Close           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the given rtn. This must be called before opening a new rtn.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8903109ba2b31277e60c7225e74120b3"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_CodeRangesProbed" ref="g8903109ba2b31277e60c7225e74120b3" args="(RTN rtn, INT32 num, PIN_CODE_RANGE *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 LEVEL_PINCLIENT::RTN_CodeRangesProbed           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPIN__CODE__RANGE.html">PIN_CODE_RANGE</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns all the dynamic code ranges associated with the given RTN. The buffer must be allocated by the tool, and be large enough to contain all code ranges. If num=0, the number of dynamic code ranges is returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rtn</em>&nbsp;</td><td>function that was replaced </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num</em>&nbsp;</td><td>number of elements, or zero. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>buffer large enough for all of the code ranges. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of dynamic code ranges copied into buffer. If num=0,it returns the number of dynamic code ranges associated with the RTN.</dd></dl>
<a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga6c9c5c444bffe61f7a37cb478517eff"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_CreateAt" ref="ga6c9c5c444bffe61f7a37cb478517eff" args="(ADDRINT address, string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_CreateAt           </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a routine object at given address. In some situations user can calculate address of routine, but Pin doesn't see it because there is no symbol at this point. <a class="el" href="group__RTN__BASIC__API.html#ga6c9c5c444bffe61f7a37cb478517eff">RTN_CreateAt()</a> allows user to create a routine at a given address and assign a name to it. When it is done, the routine can be searched for by address or by name. The information is kept in Pin as long as the containing image is in memory.<p>
The address should point to code (an executable section or segment). Since the whole code is "covered" by routine objects, the address should fall in one of the existing routines. Pin shortens the routine, which contains the given address, and creates a new routine which starts at the given address and continues till the next routine or the end of the code section. Close any open routine before calling this interface with <a class="el" href="group__RTN__BASIC__API.html#g37272253377eb65c9eb5ff47ec4f1e6b">RTN_Close()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>The start address of the new routine </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The assigned name of the new routine</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>RTN object The routine object is valid if the address fails into code section and there is no another routine object which starts at the same address.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6f86e6509f4bddb238576cda772c15de"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_FindByAddress" ref="g6f86e6509f4bddb238576cda772c15de" args="(ADDRINT address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_FindByAddress           </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>address</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>Memory address that corresponds to the RTN </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Handle to the RTN found. If not found returns <a class="el" href="group__RTN__BASIC__API.html#g8499bc83ee010e62a121237ee277224d">RTN_Invalid()</a> In a multithreaded program, the returned RTN handle could go stale if another thread unloaded the shared object that contains the RTN. Use <a class="el" href="group__PIN__CONTROL.html#gdf5abd51ee9b1d599c539a9e2784e9ef">PIN_LockClient()</a> before calling this routine and <a class="el" href="group__PIN__CONTROL.html#ga6239dd852b5236f75413209aceb7a79">PIN_UnlockClient()</a> after the last use of the returned RTN handle. Locking is automatic from an instrumentation routine, so it is unnecessary (but harmless) to lock calls to this function from an instrumentation routine. If you just want the name, call RTN_FindNameByAddress, which automatically does the locking and returns a string which will not go stale if the shared library is unloaded</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g77a2ad03e0431b881d6c3019b45261eb"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_FindByName" ref="g77a2ad03e0431b881d6c3019b45261eb" args="(IMG img, const CHAR *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_FindByName           </td>
          <td>(</td>
          <td class="paramtype">IMG&nbsp;</td>
          <td class="paramname"> <em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Img</em>&nbsp;</td><td>Image in which to search for RTN </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Name</em>&nbsp;</td><td>Name of the RTN to search in IMG </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Handle to the RTN found. If not found returns <a class="el" href="group__RTN__BASIC__API.html#g8499bc83ee010e62a121237ee277224d">RTN_Invalid()</a></dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g46d422d71d917e2cd7cd374c10804341"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_FindNameByAddress" ref="g46d422d71d917e2cd7cd374c10804341" args="(ADDRINT address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string LEVEL_PINCLIENT::RTN_FindNameByAddress           </td>
          <td>(</td>
          <td class="paramtype">ADDRINT&nbsp;</td>
          <td class="paramname"> <em>address</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the name of a function. If more than one name is associated with this address, the first name found is returned. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>Memory address that corresponds to the RTN </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Name of routine, or "" if it is not found</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g039af36fbf3aa4014f30ff8c31b41f9a"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Funptr" ref="g039af36fbf3aa4014f30ff8c31b41f9a" args="(RTN x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_Funptr           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
an rtn to a funptr<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb3b1f7eeb5a5a8b91a18f2cca866c78c"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Id" ref="gb3b1f7eeb5a5a8b91a18f2cca866c78c" args="(RTN x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 LEVEL_PINCLIENT::RTN_Id           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pin assigns each routine a unique ID. The ID is globally unique, i.e. an ID will not appear in two images. If the same routine name exists in two different images (i.e. they are in different addresses), each will have a different ID. If an image is unloaded and then reloaded, the routines within it will most likely have different IDs than before. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Unique ID for the routine.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g76bde295a78d1232fd6ff98a5ff011cf"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_InsertCall" ref="g76bde295a78d1232fd6ff98a5ff011cf" args="(RTN rtn, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::RTN_InsertCall           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert call relative to a rtn. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rtn</em>&nbsp;</td><td>Routine to instrument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>Use IPOINT_BEFORE to call funptr before execution, or IPOINT_AFTER for immediately before the return NOTE: IPOINT_AFTER is implemented by instrumenting each return instruction in a routine. Pin tries to find all return instructions, but success is not guaranteed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>funptr</em>&nbsp;</td><td>Analysis function to call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td><a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. Arguments to pass to funptr</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 NOTE: Pin does not support calling this function from either the TRACE or INS InstrumentationFunction callback </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8654a9e07644e5f6a73db1abea0899a7"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_InsertCallProbed" ref="g8654a9e07644e5f6a73db1abea0899a7" args="(RTN orgRtn, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::RTN_InsertCallProbed           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>orgRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a call to an analysis routine relative to a RTN.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>orgRtn</em>&nbsp;</td><td>the application routine to instrument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>use IPOINT_BEFORE or IPOINT_AFTER to call funptr before or after execution. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>funptr</em>&nbsp;</td><td>the analysis function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td><a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. If using IPOINT_AFTER, one IARG_TYPE must be IARG_PROTOTYPE. The list must end with IARG_END.</td></tr>
  </table>
</dl>
<a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.<p>
Use <a class="el" href="group__RTN__BASIC__API.html#g5133c810a48e94f566fecc2c11eb1f50">RTN_IsSafeForProbedInsertion()</a> to determine if a function is a suitable candidate for probed function insertion.<p>
Some restrictions apply when using IARG_CONTEXT. See <a class="el" href="group__INST__ARGS.html">Instrumentation arguments</a> for more information. IARG_THREAD_ID is not supported.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g77f0894505803bbae6da71ee1f3a3781"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_InsertCallProbedEx" ref="g77f0894505803bbae6da71ee1f3a3781" args="(RTN orgRtn, IPOINT action, PROBE_MODE mode, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::RTN_InsertCallProbedEx           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>orgRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#g707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&nbsp;</td>
          <td class="paramname"> <em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROBE_MODE&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a call to an analysis routine relative to a RTN.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>orgRtn</em>&nbsp;</td><td>the application routine to instrument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>use IPOINT_BEFORE or IPOINT_AFTER to call funptr before or after execution. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>funptr</em>&nbsp;</td><td>the analysis function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td><a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. If using IPOINT_AFTER, one IARG_TYPE must be IARG_PROTOTYPE. The list must end with IARG_END.</td></tr>
  </table>
</dl>
<a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.<p>
Use <a class="el" href="group__RTN__BASIC__API.html#gac635416e3b16a25d8bb9d157979bde4">RTN_IsSafeForProbedInsertionEx()</a> to determine if a function is a suitable candidate for probed function insertion.<p>
Some restrictions apply when using IARG_CONTEXT. See <a class="el" href="group__INST__ARGS.html">Instrumentation arguments</a> for more information. IARG_THREAD_ID is not supported.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb1bd91206939b88057664c46ef8eac86"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_InsHead" ref="gb1bd91206939b88057664c46ef8eac86" args="(RTN rtn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INS LEVEL_PINCLIENT::RTN_InsHead           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
You must call <a class="el" href="group__RTN__BASIC__API.html#gf8714086f8aebc9feacccc8cd02dc561">RTN_Open()</a> before the first time this is called for an rtn <dl class="return" compact><dt><b>Returns:</b></dt><dd>First instruction of rtn, or <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#gc811aea087098408689897c77156a74b">INS_Invalid()</a> if no instructions.</dd></dl>
Note that Pin find the INSs of the RTN through static discovery, so Pin does <em>not</em> guarantee that it will find all the INSs in the RTN. If you need completely reliable instructions, use normal JIT time instrumentation, where Pin can guarantee that the instructions are correct.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__RTN__BASIC__API.html#g2ff7a2210bc42f9367635f0bf30b24cb">RTN_InsHeadOnly()</a>, which is provided for performance purposes. If a tool wishes to examine only the first INS of an RTN it should use <a class="el" href="group__RTN__BASIC__API.html#g2ff7a2210bc42f9367635f0bf30b24cb">RTN_InsHeadOnly()</a> instead of <a class="el" href="group__RTN__BASIC__API.html#gb1bd91206939b88057664c46ef8eac86">RTN_InsHead()</a>.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2ff7a2210bc42f9367635f0bf30b24cb"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_InsHeadOnly" ref="g2ff7a2210bc42f9367635f0bf30b24cb" args="(RTN rtn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INS LEVEL_PINCLIENT::RTN_InsHeadOnly           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
You must call <a class="el" href="group__RTN__BASIC__API.html#gf8714086f8aebc9feacccc8cd02dc561">RTN_Open()</a> before the first time this is called for an rtn <dl class="return" compact><dt><b>Returns:</b></dt><dd>First instruction of rtn, or <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#gc811aea087098408689897c77156a74b">INS_Invalid()</a> if no instructions.</dd></dl>
Note that tools should use this function when they want to examine ONLY the first INS of an RTN, and NO others. The <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#g227ce58a739b1573125c11071ecb48de">INS_Next()</a> of the INS returned by this function may be <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#gc811aea087098408689897c77156a74b">INS_Invalid()</a> even if there are more INSs in the RTN. Tools that want to examine further INSs of the RTN should call the <a class="el" href="group__RTN__BASIC__API.html#gb1bd91206939b88057664c46ef8eac86">RTN_InsHead()</a> function instead of this one.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gab13f04ab2dcb762c79aea42c5aef69d"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_InsTail" ref="gab13f04ab2dcb762c79aea42c5aef69d" args="(RTN rtn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INS LEVEL_PINCLIENT::RTN_InsTail           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
You must call <a class="el" href="group__RTN__BASIC__API.html#gf8714086f8aebc9feacccc8cd02dc561">RTN_Open()</a> before the first time this is called for an rtn <dl class="return" compact><dt><b>Returns:</b></dt><dd>Last instruction of rtn, or <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#gc811aea087098408689897c77156a74b">INS_Invalid()</a> if no instructions</dd></dl>
Note that Pin finds the INSs of the RTN through static discovery, so Pin does <em>not</em> guarantee that it will find all the INSs in the RTN. If you need completely reliable instructions, use normal JIT time instrumentation, where Pin can guarantee that the instructions are correct.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8499bc83ee010e62a121237ee277224d"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Invalid" ref="g8499bc83ee010e62a121237ee277224d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_Invalid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>RTN value that indicates no valid image</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5133c810a48e94f566fecc2c11eb1f50"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_IsSafeForProbedInsertion" ref="g5133c810a48e94f566fecc2c11eb1f50" args="(RTN rtn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_IsSafeForProbedInsertion           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return TRUE if the given RTN is a candidate for function insertion using probes, and FALSE otherwise. This API should be called before attempting to insert a call to an analysis function using <a class="el" href="group__RTN__BASIC__API.html#g8654a9e07644e5f6a73db1abea0899a7">RTN_InsertCallProbed()</a>. If you want to replace the given RTN with <a class="el" href="group__RTN__BASIC__API.html#gec56561cab520a5493a599800319447b">RTN_ReplaceSignatureProbed()</a> or <a class="el" href="group__RTN__BASIC__API.html#g63500925719539624424cd62a8d027f9">RTN_ReplaceProbed()</a> you should use <a class="el" href="group__RTN__BASIC__API.html#g7e153406e2ff0031186ea67d9da1e2d7">RTN_IsSafeForProbedReplacement()</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rtn</em>&nbsp;</td><td>the application routine to be replaced. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the function can be instrumented, FALSE if it cannot.</dd></dl>
<a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gac635416e3b16a25d8bb9d157979bde4"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_IsSafeForProbedInsertionEx" ref="gac635416e3b16a25d8bb9d157979bde4" args="(RTN rtn, PROBE_MODE mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_IsSafeForProbedInsertionEx           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROBE_MODE&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return TRUE if the given RTN is a candidate for function insertion using probes, and FALSE otherwise. This API should be called before attempting to insert a call to an analysis function using <a class="el" href="group__RTN__BASIC__API.html#g77f0894505803bbae6da71ee1f3a3781">RTN_InsertCallProbedEx()</a>. If you want to replace the given RTN with <a class="el" href="group__RTN__BASIC__API.html#gae095733d136989fd0ebf49546758c65">RTN_ReplaceSignatureProbedEx()</a> or <a class="el" href="group__RTN__BASIC__API.html#g935f735a52675d54fdb5a40b99de2026">RTN_ReplaceProbedEx()</a> you should use <a class="el" href="group__RTN__BASIC__API.html#gaccf66a3919efb9807dbd86bcb4ec36a">RTN_IsSafeForProbedReplacementEx()</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rtn</em>&nbsp;</td><td>the application routine to be replaced. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>instrumentation mode, see PROBE_MODE </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the function can be instrumented, FALSE if it cannot.</dd></dl>
<a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7e153406e2ff0031186ea67d9da1e2d7"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_IsSafeForProbedReplacement" ref="g7e153406e2ff0031186ea67d9da1e2d7" args="(RTN rtn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_IsSafeForProbedReplacement           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return TRUE if the given RTN is a candidate for probed function replacement, and FALSE otherwise. This API should be called before attempting to replace a function using <a class="el" href="group__RTN__BASIC__API.html#gec56561cab520a5493a599800319447b">RTN_ReplaceSignatureProbed()</a> or <a class="el" href="group__RTN__BASIC__API.html#g63500925719539624424cd62a8d027f9">RTN_ReplaceProbed()</a>. Note that this routine does not guarantee it is safe to place a probe, it merely indicates that certain conditions are not present.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rtn</em>&nbsp;</td><td>the application routine to be replaced. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the function can be replaced, FALSE if it cannot.</dd></dl>
<a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gaccf66a3919efb9807dbd86bcb4ec36a"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_IsSafeForProbedReplacementEx" ref="gaccf66a3919efb9807dbd86bcb4ec36a" args="(RTN rtn, PROBE_MODE mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_IsSafeForProbedReplacementEx           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROBE_MODE&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return TRUE if the given RTN is a candidate for probed function replacement, and FALSE otherwise. This API should be called before attempting to replace a function using <a class="el" href="group__RTN__BASIC__API.html#gae095733d136989fd0ebf49546758c65">RTN_ReplaceSignatureProbedEx()</a>. Note that this routine does not guarantee it is safe to place a probe, it merely indicates that certain conditions are not present.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rtn</em>&nbsp;</td><td>the application routine to be replaced. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>instrumentation mode, see PROBE_MODE </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if the function can be replaced, FALSE if it cannot.</dd></dl>
<a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf9d9689a59240ecc29c80d584f268c72"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Name" ref="gf9d9689a59240ecc29c80d584f268c72" args="(RTN x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; LEVEL_PINCLIENT::RTN_Name           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Name of routine</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g491bf55c9718f8751054ebe37b460d65"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Next" ref="g491bf55c9718f8751054ebe37b460d65" args="(RTN x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_Next           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Routine that follows x, or <a class="el" href="group__RTN__BASIC__API.html#g8499bc83ee010e62a121237ee277224d">RTN_Invalid()</a> if x is the last in the section</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g540e1cb6a6c696d3da538abd5e369fc5"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_NumIns" ref="g540e1cb6a6c696d3da538abd5e369fc5" args="(RTN rtn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 LEVEL_PINCLIENT::RTN_NumIns           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute number of static INSs inside RTN.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf8714086f8aebc9feacccc8cd02dc561"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Open" ref="gf8714086f8aebc9feacccc8cd02dc561" args="(RTN rtn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::RTN_Open           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the given rtn. This must be called before <a class="el" href="group__RTN__BASIC__API.html#gb1bd91206939b88057664c46ef8eac86">RTN_InsHead()</a> or <a class="el" href="group__RTN__BASIC__API.html#g76bde295a78d1232fd6ff98a5ff011cf">RTN_InsertCall()</a> or <a class="el" href="group__RTN__BASIC__API.html#g2ff7a2210bc42f9367635f0bf30b24cb">RTN_InsHeadOnly()</a><p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd8d3497e9c27305ba5e9e77e169996ac"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Prev" ref="gd8d3497e9c27305ba5e9e77e169996ac" args="(RTN x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTN LEVEL_PINCLIENT::RTN_Prev           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Routine that precedes x, or <a class="el" href="group__RTN__BASIC__API.html#g8499bc83ee010e62a121237ee277224d">RTN_Invalid()</a> if x is the first in the section</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3a60bd22473cbf464bca49b3390c79bb"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Range" ref="g3a60bd22473cbf464bca49b3390c79bb" args="(RTN rtn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::RTN_Range           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>range of routine in bytes (until the next known symbol or end of current code region).</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g64940153e16fee5bd143a95bdf67c5af"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Replace" ref="g64940153e16fee5bd143a95bdf67c5af" args="(RTN replacedRtn, AFUNPTR replacementFun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_Replace           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>replacementFun</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace a routine in the application (<em>replacedRtn</em>) by another function defined in the Pin tool (<em>replacementFun</em>). The replacement function is not instrumented. The signature of the replacement function must be exactly the same as the replaced application routine. However, see <a class="el" href="group__RTN__BASIC__API.html#g2dcaf2242c7a62151d89c01e2f04f8c0">RTN_ReplaceSignature()</a>, which allows you to have a different signature.<p>
This API returns a function pointer to the replaced application routine's entry point, which allows the replacement function to call back to the original routine. If you do this, be sure to call the original routine via <a class="el" href="group__PIN__CONTROL.html#gf5807146670d39bc546a7f4826b52cc0">PIN_CallApplicationFunction()</a>. Directly calling the application's function pointer from the replacement function may result in a crash.<p>
This API works in JIT mode, so you must start the application with <a class="el" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replacedRtn</em>&nbsp;</td><td>The application routine to be replaced. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replacementFun</em>&nbsp;</td><td>The replacement function.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A function pointer to the replaced application routine's entry point.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT only.<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> All.<br>
 NOTE: Pin does not support calling this function from either the TRACE or INS InstrumentationFunction callback </dd></dl>

</div>
</div><p>
<a class="anchor" name="g63500925719539624424cd62a8d027f9"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_ReplaceProbed" ref="g63500925719539624424cd62a8d027f9" args="(RTN replacedRtn, AFUNPTR replacementFun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_ReplaceProbed           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>replacementFun</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace a routine in the application (replacedRtn) by another function defined in the Pintool (replacementFun) using probes. The replacement function is not instrumented. The signature of the replacement function must be the same as the replaced application routine. Replacement functions typically need to call the replaced routines. However, calls to RTN_Funptr(replacedRtn) will be redirected to replacementFun. Replacement functions must instead call or jump to the returned function pointer, which is a copy of the entry point that is not redirected.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>replacedRtn</em>&nbsp;</td><td>the application routine to be replaced. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replacementFun</em>&nbsp;</td><td>the replacement function </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a function pointer to replaced application routine's entry point. This allows the replacement function to execute the replaced routine.</dd></dl>
<a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.<p>
Use <a class="el" href="group__RTN__BASIC__API.html#g7e153406e2ff0031186ea67d9da1e2d7">RTN_IsSafeForProbedReplacement()</a> to determine if a function is a suitable candidate for probed function replacement.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g935f735a52675d54fdb5a40b99de2026"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_ReplaceProbedEx" ref="g935f735a52675d54fdb5a40b99de2026" args="(RTN replacedRtn, PROBE_MODE mode, AFUNPTR replacementFun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_ReplaceProbedEx           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROBE_MODE&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>replacementFun</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace a routine in the application (replacedRtn) by another function defined in the Pintool (replacementFun) using probes. This API is an analog to RTN_ReplaceProbed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>replacedRtn</em>&nbsp;</td><td>the application routine to be replaced. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>instrumentation mode, see PROBE_MODE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replacementFun</em>&nbsp;</td><td>the replacement function </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a function pointer to replaced application routine's entry point.</dd></dl>
PIN_StartProgramProbedEx() must be used when using this API.<p>
Use RTN_IsSafeForProbedReplacementEx(rtn, mode) to determine if a function is a suitable candidate for probed function replacement.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2dcaf2242c7a62151d89c01e2f04f8c0"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_ReplaceSignature" ref="g2dcaf2242c7a62151d89c01e2f04f8c0" args="(RTN replacedRtn, AFUNPTR replacementFun,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_ReplaceSignature           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>replacementFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace a routine in the application (<em>replacedRtn</em>) by another function defined in the Pin tool (<em>replacementFun</em>). The replacement function is not instrumented. The signature of the replacement function can be different from the replaced application routine's signature, which allows the tool to pass more (or fewer) parameters than were passed to the original application routine.<p>
The <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d0425900c8991df5d840dd6d9f9b03295">IARG_ORIG_FUNCPTR</a> argument is especially useful because it allows the replacement function to call back to the original routine. Other useful arguments are <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451db418d242314ea7c67b1febf7667e93a1">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, which allows you to pass a parameter from the original routine to the replacement function, and <a class="el" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dd12677dad18848be51b49ea0f48e07cb">IARG_PROTOTYPE</a>, which allows you define the prototype of the original routine. The IARG_PROTOTYPE argument is recommended whenever you use IARG_FUNCARG_ENTRYPOINT_VALUE. It is required if the original routine has any parameters that are not simple integral or pointer values.<p>
If your replacement function calls back to the original application routine, be sure to do so via <a class="el" href="group__PIN__CONTROL.html#gf5807146670d39bc546a7f4826b52cc0">PIN_CallApplicationFunction()</a>. Directly calling the application's function pointer from the replacement function may result in a crash.<p>
This API works in JIT mode, so you must start the application with <a class="el" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replacedRtn</em>&nbsp;</td><td>The application routine to be replaced. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>replacementFun</em>&nbsp;</td><td>The replacement function. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>...</em>&nbsp;</td><td>Any additional arguments define parameters that are passed to the replacement function, see <a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. This list must end with IARG_END.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A function pointer to the replaced application routine's entry point. The replacement function can use this pointer to call back to the original application routine, or it can use IARG_ORIG_FUNCPTR for this purpose.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT only.<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> All.<br>
 NOTE: Pin does not support calling this function from either the TRACE or INS InstrumentationFunction callback </dd></dl>

</div>
</div><p>
<a class="anchor" name="gec56561cab520a5493a599800319447b"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_ReplaceSignatureProbed" ref="gec56561cab520a5493a599800319447b" args="(RTN replacedRtn, AFUNPTR replacementFun,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_ReplaceSignatureProbed           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>replacementFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace a routine in the application (orgRtn) by another function defined in the Pintool (replacementFunptr) using probes. The replacement function is not instrumented. Replacement functions typically need to call the replaced routines. However, calls to RTN_Funptr(orgRtn) will be redirected to replacementFunptr. Replacement functions must instead call the returned function pointer, which is a copy of the entry point that is not redirected. The replacement function signature does not have to be the same as the replaced function. In fact while the replaced function may have the CALLINGSTD_REGPARMS calling convention, the replacement function calling convention must not be PIN_FAST_ANALYSIS_CALL (i.e. the replaced function may have register parameters, the replacement function must not). The replacement function arguments must be passed to the replacement function using the Pin IARG_TYPEs, in the same way as <a class="el" href="group__RTN__BASIC__API.html#g76bde295a78d1232fd6ff98a5ff011cf">RTN_InsertCall()</a>. A prototype of the routine in the application must also be passed in as an argument. See PROTO_Allocate for more information. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>orgRtn</em>&nbsp;</td><td>the application routine to be replaced. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replacementFunptr</em>&nbsp;</td><td>the replacement function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td><a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. One IARG_TYPE must be IARG_PROTOTYPE, and the list must end with IARG_END. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a function pointer to the relocated application function entry point. This allows the replacement routine to execute the replaced routine.</dd></dl>
<a class="el" href="group__PIN__CONTROL.html#g01a31bf221500b0ca0b97fb64cc62247">PIN_StartProgramProbed()</a> must be used when using this API.<p>
Use RTN_IsSafeForProbeReplacement() to determine if a function is a suitable candidate for probed function replacement.<p>
Some restrictions apply when using IARG_CONTEXT. See <a class="el" href="group__INST__ARGS.html">Instrumentation arguments</a> for more information. IARG_THREAD_ID is not supported.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gae095733d136989fd0ebf49546758c65"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_ReplaceSignatureProbedEx" ref="gae095733d136989fd0ebf49546758c65" args="(RTN replacedRtn, PROBE_MODE mode, AFUNPTR replacementFun,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AFUNPTR LEVEL_PINCLIENT::RTN_ReplaceSignatureProbedEx           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>replacedRtn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROBE_MODE&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&nbsp;</td>
          <td class="paramname"> <em>replacementFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace a routine in the application (orgRtn) by another function defined in the Pintool (replacementFunptr) using probes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>replacedRtn</em>&nbsp;</td><td>the application routine to be replaced. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>instrumentation mode, see PROBE_MODE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>replacementFun</em>&nbsp;</td><td>the replacement function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td><a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. One IARG_TYPE must be IARG_PROTOTYPE, and the list must end with IARG_END. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a function pointer to the relocated application function entry point. This allows the replacement routine to execute the replaced routine.</dd></dl>
Use RTN_IsSafeForProbeReplacementEx() to determine if a function is a suitable candidate for probed function replacement.<p>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4883c839d424578a9f6983d05e6a9a12"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Sec" ref="g4883c839d424578a9f6983d05e6a9a12" args="(RTN x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SEC LEVEL_PINCLIENT::RTN_Sec           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Section that contains this routine</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5a80e8ef7b6d02902b07ca889f4b5b35"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Size" ref="g5a80e8ef7b6d02902b07ca889f4b5b35" args="(RTN rtn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USIZE LEVEL_PINCLIENT::RTN_Size           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>rtn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>size of routine in bytes</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf0bc95e4eccdcd11cf9b3033a0d5ba78"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Sym" ref="gf0bc95e4eccdcd11cf9b3033a0d5ba78" args="(RTN x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYM LEVEL_PINCLIENT::RTN_Sym           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>SYM associated with the given routine</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6ac855c9a19a3aab44347188e6695875"></a><!-- doxytag: member="LEVEL_PINCLIENT::RTN_Valid" ref="g6ac855c9a19a3aab44347188e6695875" args="(RTN x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::RTN_Valid           </td>
          <td>(</td>
          <td class="paramtype">RTN&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if x is not <a class="el" href="group__RTN__BASIC__API.html#g8499bc83ee010e62a121237ee277224d">RTN_Invalid()</a>. <a class="el" href="group__RTN__BASIC__API.html#g6ac855c9a19a3aab44347188e6695875">RTN_Valid()</a> returns FALSE in certain cases when there is no static image of the code available, including dynamically generated code.</dd></dl>
<dl class="user" compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Apr 8 02:10:54 2013 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
